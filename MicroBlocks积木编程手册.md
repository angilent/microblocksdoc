- ![image.png](/assets/image_1671075224362_0.png)
- # 输出 OUTPUT <div style="background-color:#4852bf; height:10px;width: 10px;display:inline-block"></div>
	- ## 设置用户LED
		- ### 说明
			- 打开或关闭显示屏第一行的中间LED（或者在有TFT显示器的板子上的模拟LED）。右边的布尔开关可以是真（绿色）或假（红色）。如果为真，LED将被打开，如果为假，LED将被关闭。
		- ### 举例
			- 用户的LED灯以一秒钟的间隔被打开和关闭，形成一个永远的循环。
			- ![code_setuserled.png](/assets/code_setuserled_1671075766895_0.png)
			- 程序源码：[code_setuserled.ubp](/assets/code_setuserled_1671075883829_0.ubp)
		- ### 图片
			- ![设置用户LED.png](/assets/设置用户LED_1671075434964_0.png){:height 42, :width 161}
	- ## 说
		- ### 说明
			- 显示输入值的气泡。它可以用来显示MicroBlocks支持的任何数据类型。除了直接在字段中输入数值外，还可以在那里放置一个变量报告积木。如果要显示一个以上的数据，只需点击黑色三角形就可以打开其他字段。这是帮助排查所写代码故障的主要方法之一。
		- ### 举例
			- *数值* 变量乘以 2 的结果用 **说** 显示。
			- ![计算10x2.png](/assets/计算10x2_1671076540311_0.png)
		- ### 图片
			- ![说.png](/assets/说_1671114441273_0.png){:height 55, :width 111}
	- ## 绘图
		- ### 说明
			- 将在数据绘图显示面板中对输入的数值进行绘图。任何类型的数据都可以被绘制成图表：数字、数字引脚输入和模拟引脚输入、传感器输出等。如果要绘制一个以上的数据字段，请点击黑色三角形的附加数据字段。可以用不同的颜色绘制多达六个同时出现的数值。
			- 注意：绘图只在 IDE 中支持。因此，只有当微型设备连接到计算机时，才有可能作图。在没有连接到电脑的情况下试图作图将导致显示 "Board not connected" 的信息。
				- LATER Board not connected 还没有被翻译成中文
		- ### 举例
			- 图中积木块显示的是随机数1-10持续重复绘制的图形。图形的Y轴已经用图形选项菜单调整到了底部位置。
			- ![绘图随机数.png](/assets/绘图随机数_1671089940399_0.png)
			- ![image.png](/assets/image_1671090026260_0.png)
		- ### 数据图表面板
			- ![image.png](/assets/image_1671090701013_0.png){:height 258, :width 407}
			- 如上所述，数据图表面板显示绘图积木中读入的数值。
			  面板的 Y 轴是自动缩放的，而 X 轴会随着更多的数据被绘制成图表而侧向滚动。图形显示窗口的大小可以通过图形窗口右下角的控制来调整。窗口本身可以定位在 IDE 窗口的任何位置。
			  在记录完任何数据后，如果需要，可以关闭和打开图形显示窗口，而不会丢失任何数据或显示的图像。此外，还可以在使用中断开和重新连接微处理器，而不会丢失图形数据。
			  各种图形相关的选项可以通过图形选项菜单来控制。当人们右键点击图形面板时，它就会显示出来。
		- ### 数据图表面板选项
			- ![image.png](/assets/image_1671090734787_0.png)
			- 图形选项菜单允许控制轴的显示，以及数据导入/导出，并设置数据采样率。
			- **清除图表** 擦除图形的数据显示窗口。
			  **底部为零** 将Y轴原点置于图形显示区域的底部。
			  **讲数据导出到 CSV 文件** 实现以 CSV 格式保存图表数据。该文件被保存在 MicroBlocks 运行的PC上。只有最后的10000个数据值被导出。
			  **从 CSV 文件导入数据** 可以从运行 MicroBlocks 的 PC 上加载 csv 数据。导入的数据被绘制成图表并显示在图表面板上。只有10000个值会被导入。
			  **将图形数据复制到剪贴板（高级功能）**用于图形块的数据被复制到剪贴板上。只有最后的10000个值被复制。
			  **设置串行延迟（高级功能）** 在1-25ms之间设置数据采样率。较低的延时数字会导致较高的采样率。
		- ### 图片
			- ![绘图.png](/assets/绘图_1671089321175_0.png)
- # 输入 INPUT  <div style="background-color:#9f42a5; height:10px;width: 10px;display:inline-block"></div>
	- ## 按键 A
		- ### 说明
			- 返回微控制板上的按钮 A 的状态为真或假。按下为真，未按下为假。
		- ### 举例
			- 在一个**如果那么**积木中检查按钮A的状态，并显示一个文本信息。如果按钮A被按下，则显示 "A已按下"，否则显示 "A未按下"。
		- ### 图片
			- ![按键 A.png](/assets/按键_A_1671190608839_0.png)
	- ## 按键 B
		- ### 说明
			- 返回微控制板上的按钮 B 的状态为真或假。
		- ### 举例
			- 在一个**如果那么**积木中检查按钮 B 的状态，并显示一个文本信息。如果按钮 B 被按下，则显示 "B 已按下"，否则显示 "B 未按下"
		- ### 图片
			- ![按键 B.png](/assets/按键_B_1671190705262_0.png)
	- ## 计时器
		- ### 说明
			- 返回微型设备连接到USB端口后的毫秒数（从0ms开始）。
			  无论程序的启动/停止状态如何，定时器都会递增。为了得到一个零的起始点，请使用重置定时器块。
		- ### 举例
			- 程序的定时器被重置。等待一定的时间后，程序会显示定时器的数值。
			  ![计时器.png](/assets/计时器_1672131206547_0.png)
			-
		- ### 图片
			- ![计时器.png](/assets/计时器_1671190763021_0.png)
		-
	- ## 计时器归零
		- ### 说明
			- 将程序计时器重置为零。( ((639d4c1d-630c-4b43-a43f-e8759dead4b1)) 和 ((639d4c1d-653a-42fc-9e97-2756319343ec)) 积木不受影响）
		- ### 举例
			- {{embed ((639d4c1d-3f28-4fdd-8ef9-94a5e2558f3b))}}
		- ### 图片
			- ![计时器归零.png](/assets/计时器归零_1672032768402_0.png)
	- ## 毫秒
		- ### 说明
			- 返回微型设备连接到USB端口后的毫秒数（从0ms开始）。
			  无论程序的启动/停止状态如何，毫秒数都会递增。要得到一个持续时间，保存起始值并从结束值中减去。
		- ### 举例
			- 程序使用定时器、毫秒和微秒块计算200次加法的持续时间。
			- {{embed ((639bf7c4-6809-4a3e-bbd1-2ed21893be7f))}}
		- ### 图片
			- ![毫秒.png](/assets/毫秒_1672032951596_0.png)
		-
	- ## 微秒
		- ### 说明
			- 返回微型设备连接到USB端口后的微秒数（从0ms开始）。  
			  无论程序的启动/停止状态如何，微秒数都会递增。要得到一个持续时间，保存起始值并从结束值中减去。
		- ### 举例
			- 程序使用定时器、毫秒和微秒块计算200次加法的持续时间。
			- ![code_millismicros.png](/assets/code_millismicros_1671165902378_0.png)
		- ### 图片
			- ![微秒.png](/assets/微秒_1672033002155_0.png)
	- ## 主板类型
		- ### 说明
			- 返回连接到USB端口的主板的类型。
		- ### 主板类型列表
			- 从microBlocks v1.0.8开始，支持的板卡类型。
			- ![image.png](/assets/image_1672033070943_0.png){:height 417, :width 203}
		- ### 举例
			- 程序显示它所运行的微型设备的类型。
		- ### 图片
			- ![主板类型.png](/assets/主板类型_1672033175486_0.png)
- # 引脚 PIN <div style="background-color:#548799; height:10px;width: 10px;display:inline-block"></div>
	- ## 读取数字引脚
		- ### 说明
			- 返回微控制板上指定的数字引脚的值（真或假）。通过点击右端的黑色三角形，可以设置是否使用上拉电阻。在引脚电压波动的情况下，上拉电阻设置迫使信号变高。
		- ### 举例
			- 数字引脚 0 被连续读取，并显示和绘制出结果。设置上拉电阻意味着该线的正常状态为高电平。
			  ![读取数字引脚程序实例.png](/assets/读取数字引脚程序实例_1671178084772_0.png) ![Data Graph read digital](https://imgs.zhubai.love/ba9c4fa8209847359ac02395c9414d15.png)
		- ### 图片
			- ![读取数字引脚.png](/assets/读取数字引脚_1671177981562_0.png)
	- ## 读取模拟引脚
		- ### 说明
			- 返回微控制板上指定的模拟引脚的数值，范围为0-1023。通过点击右端的黑色三角形，可以选择是否设置上拉电阻。在引脚电压波动的情况下，上拉设置迫使信号变高。
		- ### 举例
			- 模拟引脚0被持续读取，结果被显示并绘制成图表。在测试过程中，0号针脚没有连接到任何东西。上拉功能没有启用，这意味着该线的信号状态在不断波动，从图中可以看出。
			- ![读取模拟引脚程序实例.png](/assets/读取模拟引脚程序实例_1671179345153_0.png){:height 227, :width 388}![](https://imgs.zhubai.love/064a04d156c64ca2aea5f0bbed2800ea.png)
		- ### 图片
			- ![读取模拟引脚.png](/assets/读取模拟引脚_1671178487806_0.png)
		-
	- ## 设置数字引脚
		- ### 说明
			- 设置数字引脚的状态，指定为真或假。在一个3.3V的设备上，高电平设置电压为3.3V，低电平设置电压为 0。
		- ### 举例
			- 两个循环脚本。左边的积木脚本一个在高和低设置之间切换 0 号引脚三次。由于在改变引脚状态的同时读取它可能会影响它的状态，所以用一根简单的电缆将引脚0连接到引脚 2。在右循环中，引脚 2 被读取（应反映出与引脚 0 相同的值），并作成图表。图中显示引脚 0 切换了三次。
			  ![设置数字引脚代码示例.png](/assets/设置数字引脚代码示例_1671180164771_0.png)
			  ![](https://imgs.zhubai.love/be05579cea7d41468cd4d253b028e314.png)
		- ### 图片
			- ![设置数字引脚.png](/assets/设置数字引脚_1671180237159_0.png)
	- ## 设置引脚
		- ### 说明
			- 在给定的引脚上产生一个脉冲宽度调制（PWM）信号，近似于0-1023的功率水平。PWM通过快速打开和关闭引脚来工作。功率是通过改变占空比来控制的：在每个周期中，引脚开启的时间百分比。0的值意味着引脚是关闭的，而1023的值意味着全功率（即引脚100%的时间是开启的）。值为512时，占空比为50%；该引脚有一半时间处于开启状态，一半时间处于关闭状态。PWM可以用来控制LED的亮度或电机的速度。
			  有些板子有一个或两个引脚配备了数模转换器（DAC）。当这个模块与这种引脚一起使用时，引脚输出一个稳定的电压，而不是PWM信号。0的值意味着0伏，1023的值意味着整体的电源电压（3.3伏或5伏），而512是整体电压的一半。
		- ### 举例
			- 程序以连续循环的方式读取模拟针脚2，并将模拟针脚0设置为读取的数值。这是一个由电位器控制电机的典型例子，如图所示。
			- `注意：为了清楚起见，这个模拟是简化的。真正的电机需要的功率比微控制器的输出引脚所能提供的要大。因此，在实际的电机应用中，来自微控制器的PWM信号被连接到一个驱动电机的晶体管或电机控制芯片上。`
		- ### 图片
			- ![设置引脚.png](/assets/设置引脚_1672033532402_0.png)
		-
	- ## 模拟引脚
		- ### 说明
			- 返回所连接的微型设备中存在的模拟引脚的数量。
		- ### 举例
			- 程序显示所连接设备的类型和它所支持的引脚类型和数量。
			- ![主板类型管脚数量事例.png](/assets/主板类型管脚数量事例_1671176427497_0.png)
		- ### 图片
			- ![模拟引脚.png](/assets/模拟引脚_1672033661188_0.png)
		-
	- ## 数字引脚
		- ### 说明
			- 返回所连接的主控板中存在的数字引脚的数量。
		- ### 举例
		- ### 图片
			- ![数字引脚.png](/assets/数字引脚_1672033797622_0.png)
		-
- # 控制  CONTROL <div style="background-color:#dd9f42; height:10px;width: 10px;display:inline-block"></div>
	- ## 当启动时
		- ### 说明
			- 帽子积木是在控制分组中，当点击绿色的开始 ![](https://wiki.microblocks.fun/reference_manual/common/runicon.png){:height 29, :width 18}  图标时开始运行。这些帽子积木监控着它们标题中描述的各种条件。当程序启动条件为真时，**当启动时**这个特殊的积木块就会激活。其他的则是检查按钮状态或布尔条件是否为真，然后再执行放在它们下面的积木。
		- ### 举例
			- 检测程序启动条件的简单例子。
			  ![code当启动时.png](/assets/code当启动时_1671368880654_0.png)
		- ### 图片
			- ![当启动时.png](/assets/当启动时_1671368618055_0.png)
		-
	- ## 当按键被按下
		- ### 说明
			- 这个帽子积木监控主控板按键的状态，当设备的一个按键被按下时，运行放在它下面的代码。
			  注意：不是所有的主控板都有按钮。你的代码可能无法正确运行，这取决于所用主控板。
		- ### 举例
			- 按键B的状态被监控，当被按下时，LED 面板上显示字母B。
			  ![code当按键B按下显示B.png](/assets/code当按键B按下显示B_1671369349223_0.png)
			  ![](https://wiki.microblocks.fun/reference_manual/control/code_whenb2.png){:height 148, :width 196}
		- ### 图片
			- ![当按键A被按下.png](/assets/当按键A被按下_1671369242903_0.png)
	- ## 重复执行
		- ### 说明
			- C 形状积木块是一组控制块，只要其标题中描述的条件为真，就会运行置于其中的代码。它们也被称为 LOOP 循环积木块。这个特殊**重复执行**积木会永远执行里面的积木。常用于绘制数值或连续监测端口数值等。
		- ### 举例
			- 该程序***说***“温度是多少摄氏度。”并***滚动显示***主控板上所测量的温度。
			  ![code重复执行.png](/assets/code重复执行_1671369885683_0.png)
		- ### 图片
			- ![重复执行.png](/assets/重复执行_1671370036119_0.png)
	- ## 重复几次
		- ### 说明
			- 这个C形状积木块重复执行给定数值次数。
		- ### 举例
			- 该程序通过重复 5 次来计算前5个数字的总数。在每一次重复中，变量 num 增加 1 并加入到变量total 中。最后，total 存储的结果是1+2+3+4+5=15。使用 **说** 和 **滚动显示文字** 积木显示总数 total。
		- ### 图片
			- ![重复几次.png](/assets/重复几次_1671370209645_0.png)
		-
	-
	- ## 等待 毫秒
		- ### 说明
			- 该积木暂停执行流的指定毫秒数。它被用来以一种时间可控的方式暂停和恢复代码的执行。
		- ### 举例
			- 等待 1000毫秒（1秒），让主控板的 LED 以 1 秒的间隔闪烁。
			- ![code等待毫秒.png](/assets/code等待毫秒_1671371425344_0.png)
		- ### 图片
			- ![等待毫秒.png](/assets/等待毫秒_1671371399929_0.png)
		-
	- ## 如果
		- ### 说明
			- 如果 IF 积木检查布尔条件，如果布尔条件评估为真，就执行一次包含的积木。黑色三角形允许在如果 IF块中加入多个 否则/如果 ELSE IF 条件进行扩展。如果前面的IF或ELSE IF分支不为真，那么下面的每一个ELSE IF都被连续评估和执行。
		- ### 举例
			- 变量 num 被分配一个 1-10 随机数字。除以数字 2 取余数操作被用来探测数字的奇数/偶数状态。如果操作 num 除以 2 的余数为0，则该数字为偶数，否则为奇数。
			- ![code如果.png](/assets/code如果_1671372220015_0.png){:height 287, :width 455}
		- ### 图片
			- ![如果.png](/assets/如果_1671372287475_0.png)
	- ## 当
		- ### 说明
			- 当 WHEN 帽子积木运行时，它重复检查一个布尔条件。当条件为真时，帽子下的块被运行。如果条件在执行结束时仍然为真，那么这些块将被再次运行，这个过程重复进行，直到条件变为假。
			- 注意：WHEN帽子包括周期之间一毫秒的等待。这对去掉嘈杂的输入（如按钮）很有帮助，但将性能限制在每秒钟最多1000次的迭代。要处理更高速的事件，请在FOREVER循环中使用IF语句。
		- ### 举例
			- 在这里使用当WHEN积木对与如果IF积木相同的例子进行编程。布尔型条件被设置为除以 2 取余数MOD操作结果。当点击开始START图标时，所有三个帽子积木块（当启动时WHEN STARTED，第1和第2个当 WHEN）同时开始运行。在当启动时块下面的重复执行FOREVER块不断地生成随机数。而两个当WHEN帽子积木持续执行，评估其条件并显示相应的结果。
			- ![codewhen当.png](/assets/codewhen当_1671373231624_0.png){:height 275, :width 239}
		- ### 图片
			- ![当when.png](/assets/当when_1671372961793_0.png)
		-
	- ## 直到 ...前都等待
		- ### 说明
			- 这个积木暂停程序的执行，等待指定的布尔条件为真。我可以根据监测到的事件，用于同步平行运行的代码块。
		- ### 举例
			- 在这个例子中，环境光照度是用微型设备的内置光照传感器监测的。光线传感器的范围是0-255，0代表黑暗，255代表光明。
			  当点击RUN时，两个WHEN BUTTON PRESSED块开始运行并检查按钮状态。
			  当按钮A被按下时，光线监测开始，程序等待，直到微型设备传感器报告光线水平<75。当这个条件成为现实时，就会发出开灯的警报信息。
			  按钮B被编程为关闭监测过程。当按下时，它停止执行程序的那个分支。
			- ![等待直到.png](/assets/等待直到_1671528028316_0.png)
		- ### 图片
			- ![直到 ...前都等待.png](/assets/直到_...前都等待_1671525201919_0.png)
		-
	- ## 返回
		- ### 说明
			- 返回（RETURN） 积木用于报告在其输入区中指定的数值。这可以是任何数据类型。虽然可以在程序的任何地方使用 返回 （RETURN） 积木来显示一个值，类似于 ((639a9868-ac00-4659-ae70-8d1917eba03c)) （ SAY） 积木，但它的正确和更常见的用途是在一个函数（或报告者类型的自定义积木）中返回一个值，作为那里的处理结果。返回一个值的自定义积木因此被称为报告积木 REPORTER。注意，放在返回 RETURN 积木之后的块不会被执行。
		- ### 举例
			- 为了演示 返回 RETURN 积木的真正用途，我们编写了一个名为 "这很热"的自定义积木函数。主控板的温度传感器值被用作该函数的输入。任意地，如果温度高于27摄氏度，该函数返回真（意味着它是热的）。任何其他温度值都会使函数只返回温度输入。
			  为了在程序中使用自定义积木，需要对两个 WHEN 积木进行编程，以监测和应对温度变化。一个 WHEN 积木监测由自定义块返回的真实值。当检测到时，它发出警报 "该冷却了"。
			  另一个 当WHEN 积木监测相反的情况，即当真值没有返回时。在这种情况下，程序会显示一条信息，表明当前的温度。
			  要测试该程序，只需用手指夹住微型设备处理器，让其温度根据你的体温上升。或者在传感器区域施加一个小的热源。
			- ![code这很热.png](/assets/code这很热_1671691158213_0.png){:height 320, :width 565}
		- ### 图片
			- ![返回.png](/assets/返回_1671690034765_0.png)
		-
	- ## 当接收到
		- ### 举例
			- 这个例子利用了控制类别中所有与消息相关的块。当点击 START 时，程序等待2秒，然后发送 "测试 "消息。WHEN RECEIVED 积木块正在监视消息，并特别寻找 "test"消息。当收到 test 消息时，将运行它下面的块。收到的信息将在主控板的LED屏上滚动显示，并在 IDE 中显示。
			- ![当接收到消息.png](/assets/当接收到消息_1671694229480_0.png)
			- 注意这里，广播的消息可以支持中文。但滚动显示文字不支持。
			-
		- ### 说明
			- 这个积木块通常与 ((639f1e48-29ea-4fff-a6f0-55ca18ec40b1)) BROADCAST积木一起使用，以实现程序内的通信手段。任何用广播 BROADCAST 指令发送的消息都会通过当接收到积木块检测和接收。因此，放置在这个块下的块将在接收到相应的消息后运行。消息可以是字符串，也可以是数字。另外，最新消息 LAST MESSAGE 积木块包含了最新从广播中接收的信息。
		- ### 图片
			- ![当接收到.png](/assets/当接收到_1671691863785_0.png)
	- ## 广播
		- ### 说明
			- 见上面的 ((639f1e47-2840-453b-b779-c42f7de61379))。广播积木将指定的消息内容发送至程序上下文。所有接收处理相同消息内容的 “当接收到” 消息积木都将收到该消息并对其采取行动。
		- ### 举例
			- 这个例子利用了控制类别中所有与消息相关的块。当点击 START 时，程序等待2秒，然后发送 "测试 "消息。WHEN RECEIVED 积木块正在监视消息，并特别寻找 "test"消息。当收到 test 消息时，将运行它下面的块。收到的信息将在主控板的LED屏上滚动显示，并在 IDE 中显示。
			- ![当接收到消息.png](/assets/当接收到消息_1671694229480_0.png)
			- 注意这里，广播的消息可以支持中文。但滚动显示文字不支持。
			-
		- ### 图片
			- ![广播.png](/assets/广播_1671791978400_0.png)
			-
	- ## 注释
		- ### 说明
			- 这是一个简单的块，不做任何特别的事情。它被用来在程序块序列中放置注释。
		- ### 图片
			- ![注释.png](/assets/注释_1672128311681_0.png)
	- ## 从 ... 到 ... 到数字列表
		- ### 说明
			- 创建一个数字序列，可以用于迭代。可选间隔参数。
		- ### 举例
			- 生成一个从1到10 间隔为2 的数字序列。 ![间隔.png](/assets/间隔_1672126903603_0.png)
		- ### 图片
			- ![从数字序列.png](/assets/从数字序列_1672126740656_0.png)
		-
	- ## 重复执行 变化因子
		- ### 说明
			- 带变化因子的循环积木 For 是循环C形状积木块中的一个。根据指定的输入类型，它有两种不同的操作方式。
			  如果输入是一个数字，放置在其中的积木将被执行的同输入数字一样的次数。在循环的每次迭代中，循环变量从 1 开始，每次循环控制参数 i 将增加1。这个值可以在程序代码中随意使用。
			  控制参数的名称可以通过点击 i 并输入新的名称来改变其他变量名。
			  如果输入是一个列表 LIST，放置在 for 循环块中，则运行次数与列表中的项目数相同。在每一次迭代中，i  控制参数将依次获得每个列表项的值。
		- ### 举例
			- ![for循环1.png](/assets/for循环1_1672044698916_0.png) ![for循环2.png](/assets/for循环2_1672044714099_0.png)
			- 这个例子演示了有变化因子的循环积木块的两种用法。
			  第一组块显示，输入参数是数字（ NUMBER） 类型的，则在循环的每次迭代中，i 的值为 1，2，3；而 SAY 块显示的值为1，2，3。
			  第二组块显示输入参数是列表（ LIST ）类型的。控制参数 i 的名称已经改为 item，以更好地匹配列表类型。因此，在循环的每个迭代中，item 依次取值为 cat, dog, bird；而 SAY 块显示值为 cat, dog, bird。
		- ### 图片
			- ![for循环积木.png](/assets/for循环积木_1672044791693_0.png)
	- ## 重复执行 直到
		- ### 说明
			- 这个循环的 C 形积木块用来运行放置在它里面的积木，直到指定的布尔条件为真。这时，C形积木块之后的下一个积木将被运行。
		- ### 举例
			- 在 ***重复执行直到*** （REPEAT UNTIL）积木块中检查按键 A 的状态，并显示一个文本信息。当按键 A被按下时，会显示 "检测到按键 A 被按下"。
			- ![等待直到1.png](/assets/等待直到1_1672043682748_0.png) ![image.png](/assets/image_1672043661650_0.png){:height 182, :width 320}
		- ### 图片
			- ![重复执行直到.png](/assets/重复执行直到_1672043876983_0.png)
		-
	- ## 停止当前任务
		- ### 说明
			- ***停止当前任务*** STOP THIS TASK 这个积木块和它相关的***停止其他任务 ***STOP OTHER TASKS 都是用来控制程序的执行。这个积木会阻止它所属的所有积木组，或者是同一个帽子块下的所有块的执行。一旦这个块在一组积木中被执行，那么这组积木中的其他块将不会被执行。程序的所有其他部分/积木组将继续运行。
		- ### 举例
			- 这个例子是在演示两个停止块的使用。
			      停止当前任务
			      停止其他任务
			  右边的积木组在一个连续的循环中倒数并递减其 num局部变量。
			  左边的积木组也在一个连续的循环中，倒数并递减其局部变量 num。
			  然而在 num=10的倒计时中，左边的序列对另一组进行了控制，并使用“停止其他任务” STOP OTHER TAKS块停止了它。这表现在右边块的永远循环和倒计时在 num=10时终止。当你运行该代码时，可以观察到这一点。
			  左边的块序列继续运行，同时检查条件"num < 0"。当它到达该点时，它执行“停止这个任务” STOP THIS TASK 积木，并在显示 "停止在数字 0 " 信息后终止自己的运行。
			  请注意，左边序列中的最后一个“说” SAY积木是永远不会被执行的。一旦“停止这个任务” STOP THIS TASK 被发出并完成，左边块的所有活动就被终止了。因此没有显示 "在重复执行之后”的信息。
			- ![stopthis.png](/assets/stopthis_1672127423532_0.png)
			-
		- ### 图片
			- ![stopthis积木.png](/assets/stopthis积木_1672127915741_0.png)
		-
	- ## 停止其他任务
		- ### 说明
			- 这个积木块和它的相对应的 ***停止这个任务*** STOP THIS TASK 积木都是用来控制程序的执行。这个积木块会停止程序中所有其他积木的执行。一旦这个积木在一个积木组中被执行，程序的所有其他部分/积木组将停止运行。这个块所在的积木组，或者在同一个帽子块下的积木组将继续运行。
		- ### 举例
			- {{embed ((c858d3f8-4598-4f9f-9677-c7053d8c5c1f))}}
		- ### 图片
			- ![stoopothers.png](/assets/stoopothers_1672128205838_0.png)
		-
	- ## 等待 微秒
		- ### 说明
			- 该块暂停执行流的指定数量的微秒。它被用来以一种可控的方式暂停和恢复代码的执行。
		- ### 举例
			- 参考 ((639f1aa6-5be1-4c54-876e-2452d98b63bc)) 的例子
		- ### 图片
			- ![等待微秒.png](/assets/等待微秒_1672128611357_0.png)
		-
	- ## 最新消息
		- ### 说明
			- 返回整个程序中按时间顺序发送的最后一条消息。
			- 注意，它不是特定积木序列程序收到的最后一条消息，与“当接收到”积木的执行无关。
			- 没有消息排队系统。如果没有匹配的**当接收到**等待，当发送消息时，它将被错过，并被下一条消息覆盖。
		- ### 举例
			- 左边的块序列连续发射了三条消息，中间有50毫秒的停顿。右边的程序块序列在收到消息 "one" 的时候报告最后遇到的消息。
			  当执行时，人们会看到信息 "three"，但从来没有看到信息 "one"，尽管当收到信息 "one "时，WHEN RECEIVED块被激活。这是因为代码中的 WAIT 500 MILLISECS 的缘故。这个延迟是如此之长，以至于即使这组块在收到消息 "one "时执行（当时，最后一条消息=one），到 SAY 执行时，又收到了两条消息，最后一条消息不再是 "one "而是 "three"。
			- ![消息代码.png](/assets/消息代码_1672130147527_0.png){:height 360, :width 454}
		- ### 图片
			- ![最新消息.png](/assets/最新消息_1672128810684_0.png)
		-
	- ## 调用（指令）
		- ### 说明
			-
		- ### 举例
			-
		- ### 图片
			- ![调用指令.png](/assets/调用指令_1672128489412_0.png)
		-
	- ## 调用（报告）
		- ### 说明
			-
		- ### 举例
			-
		- ### 图片
			- ![调用报告.png](/assets/调用报告_1672128509143_0.png)
		-
- # 运算 OPERATORS  <div style="background-color:#52a528; height:10px;width: 10px;display:inline-block"></div>
	- ## 加 +
		- ### 说明
			- 两数求和
		- ### 举例
			- ![c加.png](/assets/c加_1672556760874_0.png)
		- ### 图片
			- ![加.png](/assets/加_1672553641184_0.png)
	- ## 减 - 
		- ### 说明
			- 返回第一个数与第二个数之差
		- ### 图片
			- ![c减.png](/assets/c减_1672556781425_0.png)
		- ### 图片
			- ![减.png](/assets/减_1672553671587_0.png)
	- ## 乘 x
		- ### 说明
			- 返回输入两数乘积
		- ### 举例
			- ![c乘.png](/assets/c乘_1672556808104_0.png)
		- ### 图片
			- ![乘.png](/assets/乘_1672553695716_0.png)
		-
	- ## 除 /
		- ### 说明
			- 返回第一个数字除以第二个数字的商
		- ### 举例
			- ![c除.png](/assets/c除_1672556828513_0.png)
		- ### 图片
			- ![除.png](/assets/除_1672553723760_0.png)
		-
	- ## 模数取余 /
		- ### 说明
			- 模数（或 "modulo "或 "mod"）是第一个数字除以后一个数字后的余数，例如：10 模 3 等于1。因为 10/3 商 3 余数为 1 。
		- ### 举例
			- 变量num被分配一个随机数字1-10。MOD操作被用来探测数字的奇数/偶数状态。如果操作num除以2的余数为0，则该数字为偶数，否则为奇数。
			- ![codeodd.png](/assets/codeodd_1672486356294_0.png)
		- ### 图片
			- ![mod.png](/assets/mod_1672486336543_0.png)
	- ## 绝对值
		- ### 说明
			- 返回给定数字的大小（总是 >= 0）
		- ### 图片
			- ![绝对值.png](/assets/绝对值_1672554132263_0.png)
		-
	- ## 最小值
		- ### 说明
			- 返回较小的值。点击向右的箭头打开可选模式输入更多需要比较的数值。
		- ### 举例
			- ![c最小值.png](/assets/c最小值_1672554419054_0.png)
		- ### 图片
			- ![最小值.png](/assets/最小值_1672554377553_0.png)
	- ## 最大值
		- ### 说明
			- 返回较大的值。点击向右的箭头打开可选模式输入更多需要比较的数值。
		- ### 举例
			- ![c最大值.png](/assets/c最大值_1672554297319_0.png)
		- ### 图片
			- ![最大值.png](/assets/最大值_1672554154671_0.png)
		-
	- ## 在 ... 到 ... 之间取随机数
		- ### 说明
			- 返回第一个和第二个值之间随机选择的数字
		- ### 举例
			- RANDOM函数的一个常见的初学者使用方法是编写一个抛硬币正反面的实现。
			  在这里，创建了两个变量head和tails，以及一个变量num来存储RANDOM函数的结果。
			  在一个重复1000次的循环中，对正面和反面的计数进行统计。随机数1被算作正面，2被算作反面。结果在最后显示。
			- ![code随机数.png](/assets/code随机数_1672537807484_0.png)
		- ### 图片
			- ![随机数.png](/assets/随机数_1672554453668_0.png)
	- ## 小于 <
		- ### 说明
			- 如果第一个值小于第二个值，则返回 true
		- ### 图片
			- ![小于.png](/assets/小于_1672554539447_0.png)
		-
	- ## 小于等于 <=
		- ### 说明
			- 如果第一个值小于或等于第二个值，则返回 true
		- ### 举例
			- ![c小于等于.png](/assets/c小于等于_1672554765394_0.png)
		- ### 图片
			- ![小于等于.png](/assets/小于等于_1672554617284_0.png)
	- ## 等于 =
		- ### 说明
			- 如果两个值相等，则返回 true
		- ### 举例
			- ![c等于.png](/assets/c等于_1672554845959_0.png)
		- ### 图片
			- ![等于.png](/assets/等于_1672554782679_0.png)
	- ## 不等于 
		- ### 说明
			- 如果两个值不相等，则返回 true
		- ### 举例
			- ![c不等于.png](/assets/c不等于_1672557018124_0.png)
		- ### 图片
			- ![不等于.png](/assets/不等于_1672557042471_0.png)
	- ## 大于等于 >=
		- ### 说明
			- 如果第一个值大于或等于第二个值，则返回 true
		- ### 举例
			- ![c大于等于.png](/assets/c大于等于_1672557138020_0.png)
		- ### 图片
			- ![大于等于.png](/assets/大于等于_1672556541170_0.png)
		-
	- ## 大于 >
		- ### 说明
			- 如果第一个值大于第二个值，则返回 true
		- ### 举例
			- ![c大于.png](/assets/c大于_1672557159305_0.png)
		- ### 图片
			- ![大于.png](/assets/大于_1672557203323_0.png)
		-
	- ## 布尔常量 true/false
		- ### 说明
			- 布尔常量：真或假取决于选择器的位置。
		- ### 举例
			- 如果 IF 积木是一个很好的例子，可以证明这个积木的布尔值真/假使用。这个例子的代码有两种不同的执行方式。
			  第一种是一个重复执行 FOREVER循环，其中如果 IF积木的否则 ELSE IF分支被设置为假FALSE。这意味着：不要评估这个分支。因此，当运行时，只显示第一个显示信息。即使随机块产生2，它也不会被评估，因为否则 else 分支被设置为FALSE而关闭。
			  还需要注意的是如果 IF 旁边的表达式。最初，这个位置是真/假块。它被表达式num = 1取代。这个表达式的布尔值评估是真还是假，取决于生成的数字是什么。这表明可以用评价为真或假的表达式来代替这个块。
			- 在第二个例子中，重复执行 FOREVER 循环被删除，否则 ELSE 分支被设置为 "真"。
			- 这意味着：如果 IF分支不为真，就评估这个分支。因此，如果num不是1（意味着是2），这个分支将被执行，第二个信息将被显示。
			  由于随机块生成的是1和2，因此根据生成的数字显示相应的信息。
			- ![code布尔.png](/assets/code布尔_1672539154380_0.png)
		- ### 图片
			- ![布尔常量.png](/assets/布尔常量_1672554912480_0.png)
		-
	- ## 非 （不成立）
		- ### 说明
			- 反转与它所操作的布尔值的逻辑值。
			  如图所示，如果滑块被设置为 TRUE，非将返回F ALSE，如果滑块被设置为 FALSE，则返回TRUE。
			  也可以将一个评价为布尔值 "真" TRUE 或 "假" FALSE 的表达式替换到输入框中。在这种情况下，该块将评估该表达式，并根据结果，返回相反的布尔值。
		- ### 举例
			- 一个名为 string 的本地变量被设置为 "MicroBlocks is great"，一个名为 expression 的本地变量被设置为 "length of string = length of string"。
			  表达式的布尔值显然是真 TRUE。
			  当布尔值 非 NOT 应用于表达式的结果时，它被改变为相反的结果。FALSE。所有的值都被显示出来。
			- ![code布尔非.png](/assets/code布尔非_1672540080029_0.png)
		- ### 图片
			- ![不成立.png](/assets/不成立_1672555807587_0.png)
	- ## 与
		- ### 说明
			- 只有当它的任一输入为真时才返回真，否则返回假。
			  应该注意的是，由于两个条件都需要为真，所以如果在第一个条件中检测到假，就没有必要评估第二个条件；假会立即返回。
		- ### 举例
			- 两个变量tuesday和raining被设置为真。
			  然后，我们通过评估今天是否是星期二，是否在下雨来检查我们是否需要一把伞。两个条件都必须为真，我们才需要一把伞。
			  玩玩设置，自己决定吧。
			- ![code与.png](/assets/code与_1672540450090_0.png)
		- ### 图片
			- ![且.png](/assets/且_1672555922982_0.png)
	- ## 或
		- ### 说明
			- 如果任何一个或两个操作数为真，则返回真，否则返回假。
			  与布尔运算 与类似，但与之相反，这里只有两个条件中的一个为真，就能得到一个真结果。所以如果第一个条件为真，就不需要检查第二个条件。
		- ### 举例
			- 在这个例子中，我们在1-5的范围内随机生成了两个数字。然后我们检查这两个数字中的任何一个是否等于我们正在寻找的数字。
			  或积木被用来验证比较的结果。所有的数值都会被报告。
			- ![code或.png](/assets/code或_1672540801196_0.png)
		- ### 图片
			- ![或.png](/assets/或_1672555941070_0.png)
	- ## 类型是
		- ### 说明
			- 如果左边的输入项与右边的数据类型菜单选择相匹配，则返回 true。
			  数据类型在编程时是很重要的。虽然像MicroBlocks这样的环境通过处理任何数据类型的转换，使初学者很容易上手，但在比较数值看起来相同的变量时，仍有可能被视觉上的欺骗。见所提供的例子。
		- ### 举例
			- 两个变量data1和data2被设置为看起来相似的值。
			- ```
			  data1 is set to number 2
			  data 2 is set to string "2".
			  ```
			- 类型是 IS TYPE 积木被用来验证变量的类型。尽管它们看起来是一样的，但它们的类型是不同的。
			  然后我们对这两个字段进行算术运算，分别加 1。
			  由于data1已经是一个数字，所以没有问题。
			  data2是一个字符串，但在 "2 "的前面没有可见的字母字符。
			  因此，MicroBlocks 能够为我们把它转换成数字 2，并做加法。
			  最后，当我们比较 data1+1 和 data2+1 的值时，我们得到一个TRUE，因为两个表达式都演变成了数字 3。
			  现在，在数据 2 的连接块的第一个输入字段中放置任何字母后，尝试同样的方法，看看你会得到什么结果。
			- ![code类型是.png](/assets/code类型是_1672541422216_0.png)
		- ### 图片
			- ![类型是.png](/assets/类型是_1672555965732_0.png)
	- ### 高级
	- ---
	- 本节包含一些表示位操作的块。
	  位操作符与逻辑操作符（布尔）类似，只是它们是在数据的二进制表示上工作。
	  位操作符用于改变操作数中的各个位。
	  与位操作符相关的两个操作数必须是整数。
	  为了使下面的细节和例子更容易理解，我们提供了一个参考表，详细说明了十进制和十六进制的字节位置值。
		- ![hexnum.png](/assets/hexnum_1672541722041_0.png)
	- ### 剖析二进制数字
	- 二进制数是以二进制数字系统或二进制数字系统表示的数字，它只使用两个符号：通常是 "0"（零）和 "1"（一）。
	  一个字节是一个八位的二进制数。每位都是0或1。
	  要确定一个八位的二进制数的十进制值，请参考字节位置表，将二进制数有1的列的所有十进制值相加。
	- **例子**
	      二进制数字：0010 0110 十进制值。38
	- **解释**
		- ![hexc.png](/assets/hexc_1672541812514_0.png)
		- 将该列中带有二进制1的所有十进制数值合计。
		  十进制值。32 + 4 + 2 = 38
	- ## 16进制 hex
		- ### 说明
			- 将十六进制字符串转换为十进制数字。
			  简单介绍一下，十六进制数字由0-9和A、B、C、D、E、F组成。
			  因此，hex(3F)在十进制中被评估为63。
			  注意，16进制积木的输入必须是字符串类型，因为部分16进制数包含字母A-F。
		- ### 举例
			- Chrome 浏览器的 "Color For Developer's" 扩展使人们能够从网络上使用的一套调色板中挑选一种颜色。该颜色以RGB格式显示为3 个十六进制数字。
			  如果我们想使用Neopixel库块来设置CLUE rgbLED颜色，我们需要将RGB值转换成十进制等值。
			  示例程序接受3个十六进制数字并显示其十进制等值。然后它相应地设置NeoPixel的RGB值。
			- ![colorhex.png](/assets/colorhex_1672542037502_0.png){:height 161, :width 296}
			- ![codeHEX.png](/assets/codeHEX_1672542095606_0.png)
			- ![neoPixel.png](/assets/neoPixel_1672542152287_0.png){:height 242, :width 295}
		- ### 图片
			- ![十六进制.png](/assets/十六进制_1672556640549_0.png)
		-
	- ## 位与 &
		- ### 说明
			- 位与运算符对两个位进行比较，如果两个位都是 1，则返回 1的结果，否则返回0。
		- ### 举例
			- **位与**操作比较两个数字的所有位，并报告两个数字都被设置为1的位置。
			  在数字 13和 7 的二进制位上两个数字都有 1 的位置是位置 2 和 0。
			  位置 2 的十进制值是4，位置 0 的十进制值是1。
			  因此运算结果 4+1=5。
			- ![位与.png](/assets/位与_1672542454711_0.png)
		- ### 图片
			- ![位与.png](/assets/位与_1672557337389_0.png)
		-
	- ## 位或 ｜
		- ### 说明
			- 位或运算符比较两个位，如果其中一个或两个都是1，则返回1，如果两个比特都是0，则返回0。
		- ### 举例
			- 位与比较两个数字的所有比特位置，并返回其中一个数字被设置为 1 的位置。
			   115 和 9 两个数字二进制位上有 1 的位置是6,5,4,3,1和0。
			  位置 6 的十进制值是64，位置 5 的十进制值是 32，位置 4 的十进制值是 16，位置 3 的十进制值是8，位置 1 的十进制值是2，位置 0 的十进制值是 1。
			  因此，运算结果是64+32+16+8+2+1=123。
			- ![](https://imgs.zhubai.love/6932b2ff44794fef9e4c1c384f71db7c.png)
		- ### 图片
			- ![位或.png](/assets/位或_1672556184321_0.png)
	- ## 位异或 ^
		- ### 说明
			- 异或操作符比较两个二进制位，如果数字是互补的（二进制位在一个操作数中被设置，但不是两个），则产生1的结果；否则，它返回0。
			  另一种思考XOR操作的方式是，它将颠倒第二个操作数为1的位的位置，所有其他的将被复制为相同的位置。
		- ### 举例
			- 异或比较第一个操作数的所有位，并报告与第二个操作数有1的地方相反。
			  数字12在第3和第2位有一个1。数字11相同位置的位 1 0 将被反转，数字11的所有其他位将被原样复制。对于位置3和2的反转，我们得到 0 1 。
			  我们最后的结果是0000 0111。位置2、1和0为1。
			  位置2的十进制值是4，位置1是2，位置0是1。
			  因此运算结果为4+2+1=7。
			- ![异或.png](/assets/异或_1672542915413_0.png)
		- ### 图片
			- ![异或.png](/assets/异或_1672556195941_0.png)
	- ## 位非
		- ### 说明
			- **位取非**（或**补**）运算符是用来反转（BIT FLIP）操作数的所有位。
			  当一个数字的最高位变成1时，该数字被认为是一个负数。
			  MicroBlocks中有符号整数的实际计算机表示是31位。 数字31高位是一个符号位。这允许数字在-1073741824到1073741823的范围内。
			  当符号位为0时，数字为正数；而当它为1时，数字为负数。
			- *对所以操作颠倒所有位，将正数变成负数，反之亦然。*
		- ### 举例
			- 位非操作颠倒了所有二进制位，将正数变成了负数。
			  十进制 3（二进制：0011）变成十进制 -4（二进制：1100）。
			  注意：在这里使用的4位例子中，高阶位（bit-3）是符号位。
		- ### 图片
			- ![位非.png](/assets/位非_1672556225433_0.png)
	- ## 位左移
		- ### 说明
			- 左边操作数的值被向左移动，移动的位数由右边操作数指定。
			  这些位被移到左边，最左边的位被丢弃，最右边的位被赋予0的值。
			  对于每一个向左移动的位子，这个操作相当于乘以2的二进制。
			- 请记住
			  对于有符号的正数，在其二进制表示的最高有效位置上是 0 ，这个操作最终会把它变成 1，从而把这个数字变成一个负数。
		- ### 举例
			- 十进制数字 7 被左移了1位。
			  结果的二进制位置是：3、2、1位；对应的数值是8、4、2。
			  因此，该操作报告。8 + 4 + 2 = 14 。
			- ![c左移.png](/assets/c左移_1672556414282_0.png)
			- ![leftshift.png](/assets/leftshift_1672551853720_0.png)
			-
		- ### 图片
			- ![位左移.png](/assets/位左移_1672556338248_0.png)
		-
	- ### 右移 （算数右移）
		- ### 说明
			- 左边操作数的值向右移动，移动的位数由右边操作数指定。
			  这些位被移到右边，最右边的位被丢弃，最左边的位被分配一个符号位的副本。这就是所谓的算术移位。
			  对于每一个向右移动的位子，这个操作相当于二进制除以2。
			- 请记住
			  对于有符号的负数，在其二进制表示的最高有效位置上是 1，这个操作将保持符号位并连续产生负数。
		- ### 举例
			- 十进制数字 54 被右移了 1 位。
			- 结果的比特位置是：4、3、1、0位；对应的数值是16、8、2、1 。
			- 因此，该操作返回：16 + 8 + 2 + 1 = 27 。
			- ![c右移.png](/assets/c右移_1672556394820_0.png)
			- ![rightshift.png](/assets/rightshift_1672551988517_0.png)
		- ### 图片
			- ![右移.png](/assets/右移_1672556366450_0.png)
		-
	- ## 映射
		- ### 说明
			- 返回给定数值在前面数值范围的位置映射到另外一个数值范围的对应数值。
		- ### 举例
			- 将 0-10 范围中的 3 映射到 0-100 的范围中，返回值为 30。可以理解为范围扩大了10 倍。
			- ![c映射.png](/assets/c映射_1672556441692_0.png)
		- ### 图片
			- ![映射2.png](/assets/映射2_1672556455073_0.png)
		-
- # 变量 VARIABLES <div style="background-color:#d3732b; height:10px;width: 10px;display:inline-block"></div>
	- ## 新建一个变量
		- ### 说明
			- 这个块实际上是一个按钮。它创建了一个新的全局变量。
			  如果有一个同名的变量存在，新的变量将以相同的名称创建，并附加数字2。
			  例如：名字为test的变量存在。另一个变量以同样的名字被创建。新变量的名字变成了test2。
		- ### 举例
			- ![image.png](/assets/image_1671776313720_0.png){:height 264, :width 600}
			- ![image.png](/assets/image_1671776385354_0.png){:height 296, :width 454}
			-
		- ### 图片
			- ![image.png](/assets/image_1671776446326_0.png)
	- ## 删除一个变量
		- ### 说明
			- 实际上这是一个按钮。至少有一个变量已经被创建才会显示，通常是不显示的。一旦创建了一个变量，这个按钮就可以用来删除它。
		- ### 举例
			- 下面两张图片描述了变量的删除过程。
			- ![image.png](/assets/image_1671776681570_0.png){:height 295, :width 431}
			- 当点击“删除一个变量按钮”时，会出现一个所有全局变量的列表。这里是要删除的变量“测试数据”。它被选中并被点击。
		- ### 图片
			- ![image.png](/assets/image_1671777514875_0.png)
	- ## 把 ... 变量设置为 ...
		- ### 说明
			- 这个积木用来给变量赋值。它的选择菜单将显示所有全局变量和局部变量的列表。
			- ![设置变量.png](/assets/设置变量_1671786516582_0.png)
			- 为了在选择菜单中显示局部变量的名称，这个块必须被物理地连接到使用“将本地变量初始化”积木的块序列中。
			- ![image.png](/assets/image_1671786489190_0.png)
			- 除了显示变量的名称外，选择菜单还显示一个添加变量的选项。这可以用来在编辑程序代码时添加变量，而无需切换到变量类别选项
			- ![image.png](/assets/image_1671786420084_0.png)
		- ### 举例
			- 该示例代码显示了创建一个局部变量var并将123值赋给全局变量test。
			- ![变量赋值.png](/assets/变量赋值_1671786849205_0.png)
		- ### 图片
			- ![赋值变量1.png](/assets/赋值变量1_1671786935527_0.png)
	-
	- ## 将变量增加
		- ### 说明
			- 该积木按输入区给定的数值改变某个全局变量或局部变量的值。输入的数值可以是一个正数或负数。
	- ### 举例
		- 该程序改变了两个变量：全局变量 test 和本地变量 var 的值。
		- ![变量赋值举例.png](/assets/变量赋值举例_1671788165667_0.png)
	- ### 图片
		- ![改编变量.png](/assets/改编变量_1671788285251_0.png)
	- ## 将本地变量初始化
		- ### 说明
			- 该积木块用于创建和初始化局部变量。
			  默认的变量名称var可以通过点击该名称并在打开的对话框中输入新的名称来改变为其他名称。
			- 创建完成本地变量后，如果需要改变本地变量var的值，可以使用变量类别中的 ((63a5381b-de52-4aa7-9c3d-1fa41773fd27)) 积木。
		- ### 全局与本地变量
			- 一个全局变量具有下面的特点：
				- 1. 全局范围：一个全局变量可以在任何没有同名本地变量的脚本中使用，而这些本地变量又没有覆盖它。
				- 2. 生命周期长：全局变量是明确创建的，并一直存在，直到被明确删除。在脚本启动和停止时，甚至在没有脚本运行时，它都会保留它的值。然而，点击 "停止 "按钮会将所有的全局变量清除为零值。全局变量在首次创建和项目加载时也被初始化为零。
			- 与此相反，局部变量具有以下特点：
				- 1. 本地范围：一个局部变量只能在它出现的脚本中使用。如果几个脚本使用同名的局部变量，这些变量是相互独立的。
				  2. 有限的生命周期：一个脚本的局部变量在脚本启动时被创建，并在脚本终止时被删除。每次启动一个脚本（包括一个函数脚本）都会创建一个新的局部变量，而且每个脚本调用的局部变量都是相互独立的。(这就是递归的原因）。
				  3. 优先于全局变量：如果一个局部变量与一个全局变量有相同的名字，那么在局部变量出现的脚本中，局部变量会优先于全局变量。无论 "将本地变量 var 初始化为"出现在脚本的什么地方，该变量在整个脚本中都是局部变量（尽管 "将本地变量 var 初始化为 "出现在对该变量的任何其他引用之前是很好的编码实践）。
			- *关于局部变量的一切也适用于函数的参数变量。你可以把参数看作是由调用脚本预先初始化的局部变量。*
	- {{embed ((4b39a9dd-108d-41f6-ba4a-cb0c9cd33654))}}
		- ### 图片
			-
			-
- # 数据  DATA  <div style="background-color:#c44f6b; height:10px;width: 10px;display:inline-block"></div>
	- ## 第几项
		- ### 说明
			- 根据输入值的类型，返回字符串，列表，字节数组的第 n 项元素
		- ### 举例
			- 该程序初始化了两个变量：一个字符串和一个列表。
			  然后显示字符串的第九个字符和列表中的第二项。
			- ![itemcode.png](/assets/itemcode_1672360402870_0.png)
		- ### 图片
			- ![item.png](/assets/item_1672360113631_0.png)
	- ## 长度
		- ### 说明
			- 根据输入值的类型，返回字符串的长度（几个字符）或列表的长度（几个项目）。
		- ### 举例
			- 该程序显示字符串和列表的长度。
			  为了显示换行，使用了“STRING FROM UNICODE 10”积木块。
			- ![code_length.png](/assets/code_length_1672361185876_0.png)
		- ### 图片
			- ![length.png](/assets/length_1672361229993_0.png)
	- ## 连接
		- ### 说明
			- 组合字符串或列表并返回结果。两个输入必须是相同的类型。
		- ### 举例
			- 该程序显示两个连接的字符串和两个连接的列表。
			  注意，连接的列表的显示只显示了连接的列表的总项目数。
			  要真正获得项目的字符组合，需要使用JOIN ITEMS OF LIST积木。
			- ![codejoin.png](/assets/codejoin_1672361643768_0.png)
		- ### 图片
			- ![join.png](/assets/join_1672361627389_0.png)
	- ## 列表
		- ### 说明
			- 积木用来创建一个列表。项目数可以从无（空列表）到内存条件允许的数量不等。可以通过扩大黑色三角形的输入区域来添加额外的项目。
		- ### 举例
			- 创建一个空列表和一个有四个项目的列表。
			- ![codelist.png](/assets/codelist_1672362918862_0.png)
		- ### 图片
			- ![listcreate.png](/assets/listcreate_1672362934855_0.png)
	- ## 添加项目至列表
		- ### 说明
			- 将一个项目添加到列表的末尾。因为列表可以包含任何数据类型，所以添加的项目可以是任何数据类型。
		- ### 举例
			- 该程序将三个项目添加到一个名为动物（animals）的空列表中。
			  列表及其中的项目被显示出来。为了显示列表中的每个项目，使用了JOIN ITEMS OF LIST块，用逗号作为分隔符。
			- ![codeaddtolist.png](/assets/codeaddtolist_1672366293954_0.png)
		- ### 图片
			- ![addlist.png](/assets/addlist_1672366302856_0.png)
	- ## 替换项
		- ### 说明
			- 用输入中指定的值替换列表中的第n项。
			- 项目编号从1开始。
		- ### 举例
			- 该程序初始化了一个空列表，并向其添加了三个项目。
			  然后第2项 dog 被 fish 取代。
			  列表中的项目被显示出来。
			- ![code_replace.png](/assets/code_replace_1672367237081_0.png)
		- ### 图片
			- ![replace替换.png](/assets/replace替换_1672367221787_0.png)
	- ## 删除项
		- ### 说明
			- 删除一个列表中的第n个项目。由此产生的列表被缩小。
		- ### 举例
			- 该程序删除了列表中的第一个项目（cat），然后显示列表中的其余项目。
			- ![codedeleteitem.png](/assets/codedeleteitem_1672367970858_0.png)
		- ### 图片
			- ![deleteitem.png](/assets/deleteitem_1672367952893_0.png)
		-
	- ## 查找
		- ### 说明
			- 在一个字符串中找到一个字符串，或在一个列表中找到一个项目。字符串搜索将返回匹配的字符位置。列表搜索将返回匹配的项目编号。不匹配则返回-1。
			  查找的扩展模式（starting at）允许搜索从字符串的选定字符位置开始。同样的模式应用于列表允许搜索从选定的项目编号开始。
		- ### 举例
			- 本地变量 string 和 animals分别被初始化为string和list类型。
			  第一组查找对字符串进行操作，寻找 is 的出现。
			  在第3个字符处找到第一个匹配。第二组搜索从第5个字符开始，将搜索目标定位在第 6 个字符。第三次字符串搜索从字符串的末尾开始，因此没有找到任何匹配，返回-1。
			  寻找 dog 的列表搜索将其定位在列表的第2项。寻找 bird 的第二次列表搜索被指示从第3项开始，并在那里找到了它。列表中没有 fish，所以搜索返回-1。
			- ![code查找.png](/assets/code查找_1672468713399_0.png)
		- ### 图片
			- ![查找.png](/assets/查找_1672468262339_0.png)
	- ## 复制
		- ### 说明
			- 从开始到结束位置复制一个字符串，或从开始到结束项目编号复制一个列表。为了指定结束参数，需要通过点击黑色三角形进入扩展模式。
		- ### 举例
			- 这个例子初始化了一个17个字符的字符串和一个3个项目的列表。
			  第一个字符串复制操作将字符串从字符5复制到最后：是一个字符串。
			  第二个字符串拷贝提取了字符11到13：str。
			  第三个字符串拷贝没有定位任何东西，因为开始位置超出了字符串的结尾。
			  列表拷贝操作分别提取了第三项bird，第一项cat，和不存在的项。
			  请注意，所有的列表拷贝都以列表格式返回结果。
			- ![code复制.png](/assets/code复制_1672468843451_0.png)
		- ### 图片
			- ![复制.png](/assets/复制_1672468814612_0.png)
	- ## 分割
		- ### 说明
			- 通过用可选的分隔符分割指定的字符串来返回一个列表。如果没有指定定界符，那么就按每个字符分割字符串。
		- ### 举例
			- 逗号分隔的字符串被逗号分隔符分割成3个项目的列表。
			  ![split1.png](/assets/split1_1672380187493_0.png)
			- 一个在ABC后面包括一个换行符的字符串被换行定界符分割成两个项目的列表。
			  ![split2.png](/assets/split2_1672380215070_0.png)
			- 在这里，我们通过/分隔符将MicroBlocks的最新下载URL分割成若干部分。
			  ![split3.png](/assets/split3_1672380222825_0.png)
			- 如果你曾经从其他应用程序（如：计算器）或网页上复制了一个数字数据，它可能是经过格式化的。我们可以通过一系列简单的操作将其转换成整数格式。
			  ![split4.png](/assets/split4_1672380234256_0.png)
		- ### 图片
			- ![split.png](/assets/split_1672380162504_0.png)
	- ## 连接列表中的项目
		- ### 说明
			- 这个连接列表积木块接收一个列表里的项目，并将它们合并成一个字符串。如果使用了扩展模式并指定了分隔符，那么列表项就以分隔符为界。任何字符串都可以作为分隔符使用。
			- 注意，在最后一个列表项之后没有分隔符。
		- ### 举例
			- 该程序初始化了一个3个项目的列表，然后用一个分隔符显示这些项目。
			- ![codejoinlist.png](/assets/codejoinlist_1672383289667_0.png)
		- ### 图片
			- ![joinlist.png](/assets/joinlist_1672383281657_0.png)
			-
	- ## unicode
		- ### 说明
			- 返回给定字符串的第 n 个字符的 Unicode 值。输入的字符数必须在1和字符串的长度之间。该块与下面的**STRING FROM UNICODE**块的操作相反。
		- ### 举例
			- 程序显示 "HELLO "字符串的第三个字符的unicode值， L = 76。
			- ![unicodecode.png](/assets/unicodecode_1672471771087_0.png)
		- ### 图片
			- ![unicode.png](/assets/unicode_1672471752374_0.png)
	- ## unicode 对应字符
		- ### 说明
			- 返回给定十进制数字的 Unicode 字符符号。
		- ### 举例
			- 该程序根据字母表的统一编码生成大写字母并显示出来。字母A=65，Z=90。
			- ![codeunicodenum.png](/assets/codeunicodenum_1672472104951_0.png)
		- ### 图片
			- ![unicodenum.png](/assets/unicodenum_1672472056370_0.png)
	- ## 新建列表
		- ### 说明
			- 创建一个有n个指定项目的新列表，内存预分配。
			  创建的列表中的项目可以使用带有**填充**的积木块选项初始化为给定值。
		- ### 举例
			- 一个有12个项目的新列表被创建。所有的项目都被初始化为999值。然后用合并后的字符串显示该列表。
			- ![codenewlist.png](/assets/codenewlist_1672474015626_0.png)
		- ### 图片
			- ![newlist.png](/assets/newlist_1672473997198_0.png)
	- ## 新建字节数组
		- ### 说明
			- 创建一个由n个项目组成的数组，指定等待内存的可用性。每个项目都是字节大小，可以在0-255的范围内赋值。
		- ### 举例
			- 一个由 9 个项目组成的新字节数组被创建。所有的项目都被初始化为HEX值FF（0xFF）。然后显示该数组的第一个和最后一个项目。
			- ![code新建字节数组.png](/assets/code新建字节数组_1672475272566_0.png)
		- ### 图片
			- ![newbytearray.png](/assets/newbytearray_1672474733380_0.png)
		-
	- ## 作为字节数组
		- ### 说明
			- 将一个字节、一个列表或一个指定的字符串转换为一个字节数组。每一项都是字符串字母的unicode值，范围为0-255。
			  这个块在与串行IO块一起使用时特别有帮助，因为可能需要提供一个字节数组作为输入。
		- ### 举例
			- 串行写块用于将字符串HELLO作为一个字节数组发送出去。引脚0和1的回环设置允许在micro:bit显示器上读取和显示发送的信息。
			- ![codeasbytearray.png](/assets/codeasbytearray_1672475481464_0.png)
			- *请注意，在上面的例子中，作为字节数组HELLO分配给变量BUFFER是没有必要的。这样做只是为了说明 "作为字节数组 "积木的使用。我们可以轻松地使用更简单的版本：串行写入HELLO。*
		- ### 图片
			- ![asbytearray.png](/assets/asbytearray_1672475283988_0.png)
	- ## 闲置内存
		- ### 说明
			- 返回一个字符串，表示可用于分配新对象（字符串、列表或字节数组）的32位动态内存的数量。点击停止按钮会释放所有的内存。就在点击停止按钮之后，这个块报告了一个给定设备上可用的动态内存总量。根据硬件提供的 RAM 数量，设备有不同数量的动态内存。例如，micro:bit v2的内存比原来的 micro:bit 多得多。
		- ### 图片
			- ![闲置内存.png](/assets/闲置内存_1672478742072_0.png)
		-
		-
	-
- # 我的积木 MY BLOCKS  <div style="background-color:#2392dc;height:10px;width: 10px;display:inline-block"></div>
	- ## 新建命令积木
		- ### 说明
			- 这个块实际上是一个按钮。它启动了创建一个自定义块（功能）的过程。
			  这个按钮和这个类别的下一个按钮都没有实例标签和相应的代码下载。相反，这些标签提供了如何使用这些过程来创建其他块的详细描述。
			  创建一个自定义块是一个有许多步骤和选项的详细过程。
				- 1. 指定一个自定义块的名称
				  2. 添加参数和它们的标签
				  3. 改变参数的类型
				  4. 为参数指定默认值
				  5. 颜色值
		- ### 图片
			- ![addcommand.png](/assets/addcommand_1672484874562_0.png)
		- ### 常用操作
			- 在我们研究制作一个新的自定义块的过程之前，让我们回顾一下在使用自定义块头时的一些常用操作。
			- **编辑模式**
				- 当自定义块的紫色 "定义 "帽子部分或浅蓝色块部分被点击时，它就进入了编辑模式。这种模式可以通过标题参数的外观变化，以及黑色三角形的出现来识别。
				- **自定义积木 -- 一般视图**
					- ![自定义积木一般视图.png](/assets/自定义积木一般视图_1671948267224_0.png)
				- **自定义积木--编辑视图**
					- ![自定义积木编辑视图.png](/assets/自定义积木编辑视图_1671948313757_0.png){:height 88, :width 461}
					- 连续点击 "定义"帽子块区域将切换进入和退出编辑模式。
					  有时，点击黑色三角形、参数或浅蓝色块区会出现浮动的参数块或浮动的自定义块图像。这通常发生在点击时鼠标稍微移动的情况下。产生的块可以通过拖动它们到块菜单区域来安全地丢弃。或者，这些额外的块图像可以用鼠标右键单击，然后选择 "删除积木 "来删除。
						- ![image.png](/assets/image_1671948497773_0.png)
			- **添加参数和标签**
				- 这是通过点击蓝色标题块上的侧面黑色三角形来实现的。当点击块名后的右侧黑色三角形时，一个名为 "甲 "的参数将被添加。它的默认值为10。
				  当再次点击参数后面的黑色三角形时，一个有两个选项的小窗口被打开：标签和输入。
					- ![image.png](/assets/image_1671948704040_0.png){:height 198, :width 361}
				- 选择 "输入 "将导致另一个参数被添加。选择 "标签 "将添加一个标签字段。
				  当一个参数被添加时，MicroBlocks 会给它分配一个默认的名字（foo, bar, etc）和一个默认的类型（数字/字符串）。每一个额外的参数将得到一个不同的名字。
				  当一个标签被添加时，MicroBlocks 会分配一个默认的名字（label）。
			- **删除参数和标签**
				- 正如右边的黑色三角形是用来添加参数和标签的，左边的三角形是用来删除它们的。点击一个将删除最右边的项目（无论是参数还是标签）。
				  如果需要删除块头中间的一个标签，只需双击选择它，然后按删除键。
			- **重命名参数和标签**
				- 要重新命名自定义块名称标签或标题上的任何标签，只需双击选择它，然后键入一个新的名称。由于区块名称和标签只是文本字段，因此可以用空格或下划线字符分隔的多个字来创建名称。
				  如果在创建标签名称时使用了空格，产生的标签名称将被视为连续的独立标签。尽管它们被一个接一个地列出，并被视为一个连续的名称，但实际上它们是单独的文本标签。这一点只有在你以后要编辑它们时才重要。你会注意到，每个标签都需要单独编辑或删除。
				  如果在创建标签名称时使用了下划线字符，产生的标签名称将被视为一个单独的标签。
					- ![image.png](/assets/image_1671949153142_0.png){:height 133, :width 359}
				- 因此，根据你的意图，你可能发现一种方法或另一种方法更适合你的需要。
				  要重新命名一个参数，点击棕色的椭圆形参数区，在编辑窗口中输入一个新的名称。
					- ![image.png](/assets/image_1671949215503_0.png){:height 205, :width 367}
		- ### 创建自定义积木的过程
			- **指定一个自定义块的名称**
			- 当点击**新建积木**按钮时，会打开一个对话框，输入自定义块的名称。
				- ![image.png](/assets/image_1671949960466_0.png){:height 195, :width 593}
			- 点击 "确定 "按钮后，一个自定义块定义的标题就被放置在编程区。
				- ![image.png](/assets/image_1671950031179_0.png){:height 246, :width 515}
				- 现在，构成这个自定义积木的所有代码块都可以放在帽子积木下面，它们将成为新函数脚本的一部分。还要注意的是，一个代表自定义功能的新寂寞已经被放入 "我的积木 "类别窗口，默认名称为myBlock。这个默认名称可以改变。请参考通用操作。
			- **添加参数和它们的标签**
				- 虽然并不总是一个要求，但一些函数将需要参数来完成其编程功能。这些将作为函数的输入，并可以被构成自定义积木代码所使用。
				  要添加参数，参数的文本标签，以及如何编辑参数，请参考 "常用操作"。
			- **改变参数的类型**
				- 当一个参数被添加时，MicroBlocks会给它分配一个默认的名字（foo, baz, etc）和一个默认的类型（数字/字符串）。
				- ![image.png](/assets/image_1671950414182_0.png)
				- 有三种可能的参数类型：数字/字符串、布尔值和颜色。当点击棕色椭圆参数块上的黑色小三角形时，在打开的菜单中可以选择这些参数。
				  对于数字/字符串类型的参数，还可以通过右击所示的参数值（10），并从菜单中进行选择，将其类型限制为只限于数字或字符串。
					- ![image.png](/assets/image_1671950459089_0.png)
				- 下面是一个自定义块定义的例子，其中使用了所有的参数类型，并改变了默认标签。
					- ![自定义积木.png](/assets/自定义积木_1671950992625_0.png)
				- 下面是自定义积木视图和它产生的显示结果。
					- ![执行结果.png](/assets/执行结果_1671951182680_0.png)
				- 注意，这个函数的名字看起来像“我的积木 字符串”。事实上，函数名是我的积木。“字符串”是第一个参数的名称。然而，由于MicroBlocks通常不允许在标签后面输入标签，因此有必要先创建参数“我的名字”，然后双击函数名“我的积木”，并在其后面加上" 字符串"（空格字符串）。
				- 这种技术看起来很奇怪，但完全没问题，因为函数名从来没有像基于文本的编程语言那样专门单独使用。自定义块，就像所有其他块一样，被拖放到编程区，不管其名称如何。尽管如此，你决不能创建多个标签名称相同的自定义块。事实上，你不能这样做，因为 MicroBlocks 会分配一个编号的名字，并使其独一无二。
				- 下面是如果尝试创建另一个myBlock自定义块时的情况。
					- ![image.png](/assets/image_1671954352628_0.png)
				- **为参数分配默认值**
				- 正如你在上面的自定义块定义图片中所看到的，最终的块视图为每个参数显示了值，"一些文本"，10，布尔值 true，以及2342430的绿色颜色。这些被称为默认值。在创建自定义块的定义时，只需输入这些参数，就可以将它们分配给参数。你必须在编辑模式下才能做到这一点。请看常用操作。
				- **颜色值**
				- 字符串、数字和布尔类型的默认值设置是相当不言自明的。然而，颜色类型需要一些解释。
				  正如在示例的自定义块结果显示中可以看到，颜色绿色值显示为2342430。我们来剖析一下这个值，看看它代表什么。
				  如果点击自定义块上的绿色圆圈，就会显示一个颜色面板，显示构成这个特定绿色的R=35、G=190、B=30的十进制值。
					- ![](https://imgs.zhubai.love/5b3deca918324e998621857024500798.png)
				- 如果将这些十进制值中的每一个转换为十六进制的对应值，就会得出以下结果。
					- ![](https://imgs.zhubai.love/2cedfda6122e4b8691e2c8481312d1b7.png)
				- 当这三个十六进制数字按照RGB的顺序挨在一起时，我们得到一个十六进制数字0x23BE1E。而十六进制数字0x23BE1E转换为十进制就是2342430。
	- ## 新建报告积木
		- ### 说明
			- 这个块是一个按钮。启动创建一个可以报告结果的自定义块（函数）的过程（见数据类别中的REPORT块）。
			  这个操作与上面的操作的主要区别在于，这里创建的自定义块定义将有能力使用返回积木块报告一个值。
			  这种独特的能力将允许自定义块在任何需要输入参数的块中使用，并且它将把报告的值传递给该操作。
			  创建和编辑报告类型的自定义块的所有其他方面与上面的相同。
			- 关于返回 (RETURN) 积木块的使用。
			  放在它后面的任何块都不会被执行。
			  可以有多个返回（RETURN）积木，处理不同的条件并返回各自的值。
		- ### 图片
			- ![addreporterblock.png](/assets/addreporterblock_1672484661185_0.png)
- # 通讯 COMM <div style="background-color:#cc5633; height:10px;width: 10px;display:inline-block"></div>
	- 通讯类包含了通过互连电路（I2C，读作 "eye squared sea"）或串行外设接口（SPI）总线与硬件设备通信的块。这些高级块通常由具有硬件经验的人使用，为传感器或Hummingbird:bit机器人套件等设备创建库。
	  要使用这些块，你需要研究感兴趣的硬件设备的数据表。许多I2C和SPI设备在使用前必须进行配置或启用。找到并研究该设备的现有库的源代码通常很有帮助。
	- ## I2C 读取设备 寄存器
		- ### 说明
			- 返回给定I2C设备（0-127）的给定寄存器（0-255）的值。检查I2C设备的数据表，了解设备地址和寄存器的分配情况。
			  如果成功，该块返回一个正的8位值（0-255）。负的返回值表示一个错误，如I2C没有响应。
		- ### 图片
			- ![i2c读取寄存器.png](/assets/i2c读取寄存器_1672727311733_0.png)
	- ## I2C 设置设备 寄存器
		- ### 说明
			- 将一个8位字节（0-255）写入给定的I2C设备的寄存器。
		- ### 图片
			- ![i2c设置寄存器.png](/assets/i2c设置寄存器_1672727411415_0.png)
	- ## I2C 读取列表
		- ### 说明
			- 从给定的I2C设备接收多个字节。调用者提供一个列表，其长度为要读取的字节数。如果成功，该操作将用从设备中读取的字节替换该列表中的项目。
		- ### 图片
			- ![i2c读取列表.png](/assets/i2c读取列表_1672727533023_0.png)
	- ## I2C 写入列表
		- ### 说明
			- 向指定的I2C设备发送多个字节。该列表应包含范围为0-255的整数。
		- ### 图片
			- ![i2c写入列表.png](/assets/i2c写入列表_1672727550332_0.png)
	- ## spi 发送
		- ### 说明
			- 向 spi 设备发送一个字节（0-255）。
			- SPI 硬件同时发送和接收数据。在每个时钟脉冲上，从 SPI 输入线上读取一个比特，同时在SPI输出线上输出一个比特。在发送字节时，该块会丢弃从 SPI 总线上收到的字节。
		- ### 图片
			- ![spi发送.png](/assets/spi发送_1672727875717_0.png)
	- ## spi 接收
		- ### 说明
			- 从SPI设备中读取一个字节，同时发送一个零字节，并返回收到的字节。
		- ### 图片
			- ![spi接收.png](/assets/spi接收_1672727941795_0.png)
	- ## spi 设置速率
		- ### 说明
			- 设置 spi 传输速率
		- ### 图片
			- ![spi设置速率.png](/assets/spi设置速率_1672728060596_0.png)
	- ## spi 交换数据
		- ### 说明
			- spi 传递字节数组
		- ### 图片
			- ![spi交换字节.png](/assets/spi交换字节_1672728174548_0.png)
	- ## 串口打开
		- ### 说明
			- 以指定的波特率打开串口。在开始使用串口通信之前，这是必要的。根据所使用的微型设备，串口位于设备的不同引脚上。请参考WIKI特殊引脚部分，了解设备的具体引脚编号信息。
			- ```
			  由于缺乏硬件支持，串行端口支持不适用于micro:bit v1设备。
			  ```
		- ### 举例
			- ![串口测试接线.png](/assets/串口测试接线_1672729248292_0.png)
			- ![code_serialtest.png](/assets/code_serialtest_1672729203909_0.png)
			-
			- 这个例子使你能以最简单的方式体验串行端口块集。该示例程序使用了所有的串行端口块。
			  只需用鳄鱼线连接micro:bit v2设备的0号和1号针脚，创建一个环回电路。
			  这将使样本程序在针脚1上发送字符串 "HELLO"，并在针脚0上连续接收它，当按钮A被按下时。当你完成后，你可以按下按钮B并关闭串行端口。
			- > 注意：在示例代码的读/显示循环中插入500ms的延迟，只是为了使显示的字母全部可见。
			  读取串行块将在没有任何延迟的情况下运行。
		- ### 图片
			- ![串口打开.png](/assets/串口打开_1672728286173_0.png)
	- ## 串口关闭
		- ### 说明
			- 关闭并终止串口通信。
		- ### 图片
			- ![串口关闭.png](/assets/串口关闭_1672728305870_0.png)
	- ## 串口读取
		- ### 说明
			- 返回从串行端口读取的数据的字节数组。在这些数据可能代表字符值的情况下，需要使用unicode块的字符串将它们转换为实际的字母。
			  下面是一个从上面的示例程序中读出的字符串 "HELLO "的例子。你所看到的是字母的十进制代码。
			  H: 72
			  E: 69
			  L: 76
			  L: 76
			  O: 79
			  ```
			  字节数组包含0-255的字节值。
			  ```
		- ### 图片
			- ![串口读取.png](/assets/串口读取_1672728424316_0.png)
	- ## 串口写入
		- ### 说明
			- 将一个字节、一个字符串或一个字节数组写到串行端口。
			  如果你想写一个字节数组到串口，你可以用新添加的块在数据类块下的**作为字节数组**轻松地创建一个。
			  下面是该块输出的图片。
		- ### 图片
			- ![串口写入.png](/assets/串口写入_1672728484220_0.png)
	- ## 串口写入开始于
		- ### 说明
			- 返回什么呢？
		- ### 图片
			- ![串口写入开始于.png](/assets/串口写入开始于_1672728869553_0.png)
	- ## 软串口写入在给定引脚
		- ### 说明
			- 用设定的速率在给定引脚写入数据到模拟串口。
		- ### 图片
			- ![软串口写入.png](/assets/软串口写入_1672728939927_0.png)
			  