- 串行通信是如何工作的？
  了解字符的串行传输是如何工作的并探索 MicroBlocks 串行库。
- # 概述
- 使两个板子相互交谈的最简单方法是通过串行通信。串行通信在我们的日常生活中无处不在。USB、蓝牙、电视遥控器、WIFI路由器等都是利用串行通信的设备。我们可以在MicroBlocks串行库的帮助下轻松学习如何利用这项技术。
  
  在这个令人兴奋的教程中，我们将学习如何使用micro:bit v2 设备和串行库来传输信件。此外，我们将展示如何在不使用该库的情况下编码这种信件。而在这个过程中，我们将探索字母是如何被编码、发送和接收的，一点一点地使用串行通信技术。
- > 注意：如果你有兴趣在其他硬件平台上尝试这个教程，请参考[[主板特殊引脚]]一文，以了解各种平台上可用引脚的正确分配。
- # 零件
- 为了完成本教程，我们需要。
  一个micro:bit v2设备（或同等设备）
  ![](https://imgs.zhubai.love/c200e4ef15fb4a7da29e5b4449b9aae9.png)
- 鳄鱼夹或跳线
  ![](https://imgs.zhubai.love/33d8c51123934eaaa8583e5abe6c1cad.png)
  
  （可选）一块扩展板（如下图所示的三个样品）
  ![](https://imgs.zhubai.love/5ad56f99207046b59cf37700d1f41d5e.png)![](https://imgs.zhubai.love/aa83f9901206489a9101e659310c0e65.png)![](https://imgs.zhubai.love/a6c7d84787fc4de9a02e862133405e01.png)
- # 进行连接
  
  虽然有可能只用一个micro:bit和一根鳄鱼线，但这种设置会有点不稳定，难以管理。更安全和更容易的方法是使用扩展板来进行连接。这将帮助你实现更稳定的连接和性能。
- 下面是两种设置连接的方法。
  ![](https://imgs.zhubai.love/15d662e66e2e42d98b80e28cf011f08d.png)
- # 脚本
  
  对于这个练习，我们提供了一个单独的脚本，演示了两种技术。
  如何使用MicroBlocks串行库来发送/接收信件
  以及如何通过编写我们自己的代码来实现同样的功能
  
  在下面的脚本图片中，下面的块。
  当开始时，区块帮助设置项目的操作细节，并提供可选的发送比特的图表。
  
  ![](https://imgs.zhubai.love/be52b17b63d1406398882a247ef5dfd6.png)
  
  ![](https://imgs.zhubai.love/57b30e04046c44e6a1ba37e200a4aed9.png)
- 当按钮A被按下时，就会使用串行库发送和接收字符。
  ![](https://imgs.zhubai.love/a3c8233b66884e51a79ba4ffa12e12e6.png)
- 当按钮B被按下时，区块使用我们自己的编码串行通信功能发送和接收信件。
  
  ![](https://imgs.zhubai.love/567879f4ddf242418aa240bacdff54dc.png)
- > 注意：在开始时的代码块中，有与Button-A 和 Button-B版本有关的代码块。为了简单起见，在描述每个版本的块时，与特定版本无关的块已经被排除在外。同样，在两个版本中都有各种信息显示块，由于其功能简单，所以没有涉及（例如： yy#和 yy# 块）。
# 过程

对于那些只对通过micro:bit的两个端口发送和接收信件的高级功能感兴趣的人来说，下面是对串行技术的简要描述。对于那些对串行通信和UART操作有兴趣的人来说，我们想把你转到下面的 "做同样事情的两种方法 "中的 "编写我们自己的代码 "部分。
- ## 串行通信基础知识
- 在我们深入了解块的细节之前，让我们回顾一下使用串行接口进行字符传输的基本原则。
  
  字符是以二进制格式传输和接收的，一次一个比特。最小有效位（LSB）首先被传送，然后依次传送所有其他位。
  
  字母的二进制编码
  
  为了得到任何字母的二进制格式，我们需要经历一个将字符的unicode值转换为其二进制等值的过程。为了更好地解释我们正在谈论的内容，这里有一个示例表格，显示了字母及其unicode和二进制值。
- ![](https://imgs.zhubai.love/a8b6c3ca2f294c359bdc6d2a43b0fe39.png)
- 可以看出，每个字母都有一个与之相关的二进制值。这个由1和0组成的二进制值就是在电缆上传输的内容。这种数据的1和0性质非常适用于传输目的。我们都知道，计算机喜欢1和0，知道如何处理它们。在串行通信中，这些 "1 "和 "0 "被表示为micro:bit引脚上的电压变化。
- 1 位用高电压表示
- 0 位则用低电压表示
  
  例如，如果我们把字母 M 的 ASCII 值为 77，二进制编码为 01001101，计算机将把这个二进制值作为一串数字信号传输，看起来像这样。
  
  ![](https://imgs.zhubai.love/934d42e71bf84ccbb5ab032ec024613c.png)
  
  还有一些更多的技术细节会影响到一个成功的串行传输。但就我们的目的而言，了解编码及其数字表示法就足以通过本教程了。
- ## 二进制编码过程
  
  现在，我们如何从一个字母到它的二进制编码格式？
  
  很简单! 我们写一个自定义块并进行转换。这只是一个十进制到二进制的转换程序。我们把一个字母的十进制ASCII值输入我们的自定义块，它返回一个由代表相应二进制值的1和0组成的列表。由于MicroBlocks的数字信号块是用 "真/假 "值而不是 "1 "和 "0 "来工作的，所以我们的自定义块也会返回以真/假格式编码的二进制列表。为了详细说明前面的例子，字母M将被编码为。FTFFTTFT，其中F：假（0），T：真（1）。
  
  我们的自定义块的代码非常简单，如下所示。
  
  ![](https://imgs.zhubai.love/5ceaea7bce0b4d69b20182085cc417ab.png)
- # 做同一件事的两种方法
- 正如我们在开头提到的，我们将介绍两种不同的方式来完成我们的字符传输。
- ## 使用MicroBlocks 串行库
  
  这是一个简单的方法! 所有艰苦的工作都是由MicroBlocks完成的，我们所需要做的就是从库中挑选几个块，然后去做我们的事情。由于有了Serial库，我们可以免去所有串行传输的技术细节。
  
  这个版本的任务在我们的项目中被编码为Button-A 活动。
  
  Button-A 活动由两个平行运行的独立任务组成。
  
  一个用于发送活动的任务
  
  一个用于接收活动的任务
  
  当你按下Button-A时，这两个并行的任务将开始运行。发送方将告诉库区块发送所选的字符，而接收方将告诉库区块接收并存储该字符。
  
  一旦你完成了 "建立连接 "一节中所描述的连接，你就可以通过以下方式进行试验。
  
  按下micro:bit上的RESET按钮来初始化一切
  
  然后按 A 按钮
  
  **按重启 RESET 应该做以下事情。**
  
  当**开始积木块**
- 变量BAUD将被设置为传输速度
  
  ![](https://imgs.zhubai.love/c58e58773fd14d45b8e6526dbeaafc11.png)
- 初始化要使用的发送和接收引脚
  
  ![](https://imgs.zhubai.love/07ab0cf2a65e40f7b60fa7d56a80a545.png)
- 一个随机选择的字符（A-Z）将被放入char变量中
  ![](https://imgs.zhubai.love/2bcc3f1c0b194d78b6782e96cc907869.png)
- micro:bit 的LED显示屏上将显示一个复选标记，表明设置部分已经完成。
  按下按键A Button-A 应该做以下事情。
  
  **发送部分**
- 图形显示控制将被初始化
  ![](https://imgs.zhubai.love/5e894cf112b54d5e8573a3ffd44d91ff.png)
- 选择的字符将显示在micro:bit的LED显示屏上。
  ![](https://imgs.zhubai.love/a22150f6e3204314b48eb39a0a175f18.png)
- 串行库块串行打开将以规定的速度打开连接，串行写入将把字符送出。
  ![](https://imgs.zhubai.love/9cb2c8c59e4641d2b6dd4b4da0e0ecc4.png)
- **接收部分**
- micro:bit将显示一个笑脸，表示接收已经开始。
- 变量pinValue将被分配给从pin-0接收的字符。
  ![](https://imgs.zhubai.love/c825404dc8364be2b473e70b6dda3aa9.png)
- 收到的字符将显示在micro:bit的LED显示屏上
  ![](https://imgs.zhubai.love/045f8aae93a348289d915a886ae0304d.png)
- 图形活动将被停止
  ![](https://imgs.zhubai.love/9d906925262a4bfe9ac67966884bd404.png)
- 收到的字符的ASCII值将使用自定义块dec2TF和TF2INT转换为二进制格式。
  ![](https://imgs.zhubai.love/7a1ad695a2b2458eb2b0cf9359ff89bd.png)
- 脚本将显示收到的字符的细节和它的编码信息。
  ![](https://imgs.zhubai.love/fb7320d03f9d4727aa1629ca4d7489d4.png)
## 自己写代码实现

这样你才能从本教程中获得最大的收获 所有的艰苦工作都必须由我们来完成。另外，在这一节中，我们将提供有关所使用的块和它们的功能的更多详细信息。

这个版本的任务在我们的项目中是在Button-B活动下编码的。

Button-B活动由两个平行运行的独立任务组成。
- 一个用于发送活动的任务
- 一个用于接收活动的任务
  
  当你按下Button-B时，这两个平行任务将开始运行。当发送方将忙于传输正在发送的字符的比特时，接收方将处理收到的每一个比特并存储它们，直到完成一个完整的传输。
  
  虽然这一切听起来几乎与Button-A的描述一样，但有一个巨大的区别。在这个版本中，计算机将按照我们要指示的方式进行字符传输。将不会有库区来帮助我们。
  
  一旦你完成了 "建立连接 "一节中描述的连接，你就可以通过以下方式进行尝试。
  * 按下micro:bit上的RESET按钮来初始化一切
  * 然后按B键
-
- **按RESET应该做以下事情。**
  
  当启动块时
  
  变量BAUD将被设置为传输速度
  
  ![](https://imgs.zhubai.love/62b54ff94a7a4a6c81b147212b26d8bc.png)
- BAUD值代表什么？
  
  它只是说明我们想在一秒钟内传输的比特数。我们在这里有可能有各种数值：从20到2400。
  还有更高的值，但由于性能细节和编码的复杂性，我们的代码只能在这些限度内可靠地运行。
  
  计算变量 DELAY。
  
  ![](https://imgs.zhubai.love/70b0fb7c32814f12a3a6ce0ce5cfd1a3.png)
- 这里要解释一下为什么我们需要这个变量。
  
  当我们一个接一个地传输字符的位时，需要有一种方法让接收方知道什么时候一个位已经结束，什么时候一个新的位开始。由于我们只用一根电缆进行传输，所以没有其他信号参与，我们可以依赖。因此，我们要创造一种方法来发送和接收比特，而不把信号混淆。
  
  下面是一个可以实现的简单方法。
  
  我们找出一个起始信号（起始比特），然后在发送每个比特之前等待一个特定的时间。在每个比特之后，我们也要等待完全相同的时间。这个时间量就是我们所说的DELAY，它只是在这一步骤中被计算出来。
  
  为了能够使用微秒作为我们延迟期的单位，我们将100万除以BAUD速率。这就告诉我们，我们需要在比特的传输之间等待DELAY微秒。
- 初始化图形信息引脚
  ![](https://imgs.zhubai.love/48c9052505f74eb2b3bec795d958ed48.png)
- 这个引脚用于绘制收到的比特模式图。它可以是系统中任何可用的引脚。关于具体的引脚信息，请参考WIKI文章，了解各种平台上可用引脚的正确分配。
- 初始化要使用的发送和接收引脚
  
  ![](https://imgs.zhubai.love/fb9197f31e234291abdee0c69087ebb4.png)
- 串行通信可以发生在微型计算机的任何两组引脚之间。在我们的例子中，这些是用于接收的Pin-0和用于发送的Pin-1。
  
  虽然我们的代码的库版本必须遵守库的惯例，并使用针脚0和1作为串行块，但我们不需要遵守这个规则。我们正在编写自己的方法，我们可以使用我们想要的任何两个引脚。我们只是需要注意在选择针脚时不要与其他micro:bit的功能相冲突。所以，在最初的测试中，使用0和1这两个针脚。 然后你可以用其他的针脚进行实验。
- 一个随机选择的字符（A-Z）将被放置到char变量中
  ![](https://imgs.zhubai.love/3c58f88f7ff2479eb92c2d1759863de3.png)
- 在字母的二进制编码一节中的字母A-Z和a-z的表格，给我们列出了每个字母的编码方式。这里我们用一个随机函数在65和90之间挑选一个数字。这些数字代表大写字母的ASCII值。这样，我们每次运行代码时都会选择一个不同的字母。
  
  变量bitsList是通过将所选字符的ASCII值转换为二进制等值来计算的。
- 在MicroBlocks中没有数字系统转换功能，除了从HEX到Decimal的转换。从ASCII值到二进制的实际转换必须由我们编写的一个自定义块来完成。下面是它的代码。 
  id:: 63b3995e-b133-4fba-96f8-792284f25c36
	- ![](https://imgs.zhubai.love/5d75f7fff0234ff79968dd4f4c06b8fe.png)
	  id:: 63b39a0e-3f16-482b-9ea9-b6eff1fcd93d
- 这是在互联网上可以找到的许多算法的一个简单版本。如果对细节感兴趣，你可以查找并研究它。
  
  另外，二进制编码过程一节提供了关于这个自定义块的进一步细节。
  
  micro:bit的LED显示屏上将显示一个复选标记，表明设置部分已经完成
  
  Pin-1（发送引脚）被设置为真（高）状态。
  
  ![](https://imgs.zhubai.love/5c60c2e8bb8247de8ded4b7ad93023d0.png)
  
  这方面的解释将在下面的B按钮部分。
  
  比特的绘图开始了。
  
  ![](https://imgs.zhubai.love/595cba5e71d448468039c7c88bdeb7a2.png)
  
  我们在开头部分提到，我们的代码也可以对发送和接收的比特进行绘图。这个程序块检查布尔变量stopGraph的状态，并不断地对读取数字GRpin（这里是Pin-2；但可以是任何指定的Pin）的结果进行绘图。GRpin由一个并行运行的块组不断地更新，该块组在程序启动时就开始运行。
  
  ![](https://imgs.zhubai.love/cbda7eb5a9004241b3ef3e310854a82f.png)
  
  这个简单的循环不断地把接收引脚Pin-0的状态复制到GRpin。这样，当我们连续绘制GRpin的值时，我们实际上是在绘制接收的比特值。
  
  这就完成了对代码中何时启动部分的解释。现在我们可以继续描述按下Button-B时的活动。
  
  **按下 Button-B 应该做以下事情。**
  
  让我们从大局回顾一下我们在本节中要完成的所有工作。
- 就发送活动而言，我们需要向接收方发出信号，告诉他们我们开始传输比特了。然后我们需要以适当的延迟发送字符的所有8个比特。最后，我们将发出信号说我们已经完成了。
- 至于接收方的活动，以下是必须发生的事情。
  我们等待传输信号的开始。当我们检测到它时，我们开始从Pin-0读取比特，直到全部8个比特被接收。在收到完整的字符后，我们显示信息并停止。
  
  让我们来详细了解一下这些块。
  
  **发送活动。**
  
  选择的字符将显示在micro:bit的LED显示屏上
  
  ![](https://imgs.zhubai.love/21981e55ddea4c6d9fe56b073cf7f585.png)
  
  在一秒钟的等待后，我们将显示字符">"，以示我们开始进行比特传输。
  
  ![](https://imgs.zhubai.love/9a1ca1ccc85d49a79457e54a80b9c17c.png)
  
  引脚1（发送引脚）被设置为真（高）状态。
  
  这使我们准备好向另一方发出信号，表明字符传输即将开始。我们将Pin-1信号设置为真。然后我们等待DELAY微秒，然后在下一步，我们把它设置为假。
  
  ![](https://imgs.zhubai.love/76a4ca2b3b2e4d4aa2726102769390c3.png)
  
  这里是开始信号。引脚1被设置为假。
  
  ![](https://imgs.zhubai.love/116d92b7d7e54765a10cf955f39c004e.png)
  
  然后我们等待DELAY微秒。
  
  我们开始在一个循环中发送所有8位的字符，在每个位之后等待DELAY微秒。
  
  ![](https://imgs.zhubai.love/346f29b0184e4e43812c058023cacfe1.png)
  
  在启动块设置时，我们已经将我们的字符的位表示存储在变量bitsList中。在这里，我们通过该列表进行迭代，并通过改变Pin-1的状态来发送比特（真/假）的值。
  
  送出停止信号。引脚1被设置为真
  
  ![](https://imgs.zhubai.love/055de231f94040a480d4704650cb5c9b.png)
  
  一旦我们完成了所有的八位，我们就向另一方发出信号说我们已经完成了。我们通过将Pin-1设置为真状态，并等待DELAY微秒来完成这个工作。
  这就完成了Button-B的发送活动的过程。
  
  现在，让我们来看看在接收端发生的平行事件。
  
  **接收活动。**
  
  我们开始准备变量比特作为一个空的列表，它将被用来存储进入的比特。
  
  ![](https://imgs.zhubai.love/34cd1057346d434c8ab5c6d5d6ba1f8e.png)
  
  然后我们开始监测0号针脚（接收针脚）的启动信号。Pin-0变成假的。
  
  ![](https://imgs.zhubai.love/61a1d8b4ae2742cf80dc685a408fe05c.png)
  
  当我们检测到启动信号时，我们等待DELAY微秒，然后准备接收比特。
  
  在一个循环中接收所有8个比特，并将它们存储在比特列表中。
  
  ![](https://imgs.zhubai.love/175531893d7e4910a55bae260ffa1666.png)
  
  我们通过将Pin-0的值添加到比特列表中来存储接收到的比特值（真/假）。
  
  当所有的比特被接收后，我们等待大约一秒钟并将布尔变量stopGraph设置为true。这使得图形窗口在最后一个比特之后显示一小段图形活动，然后停止绘图。
  
  ![](https://imgs.zhubai.love/2bc6635239bf43c6ad5850bf51caada2.png)
  
  图形图片将看起来像这样，这取决于所收到的字符的位值。下面是一个字母M的图形。
  
  ![](https://imgs.zhubai.love/349c8216da6d4f23a77672f67af2ca3a.png)
  
  收到的比特被从比特列表的真/假格式转换为十进制的ASCII值。这是由我们编写的一个自定义代码块完成的。TF2dec。下面是它的代码。
  
  ![](https://imgs.zhubai.love/63fbb3ce46854c058c5d8e5513471226.png)
  #+END_EXPORT
  
  这个块集计算收到的比特的十进制值。由于比特是以真/假值接收的，另一个小的自定义块集TF2INT被用来将它们从真/假转换为1和0的值。下面是这方面的代码。
  
  ![](https://imgs.zhubai.love/ 59d50c41c3cc4a3886622f3151167d84.png
  
  可以看出，它执行了一个简单的真/假值到1和0的转换。
  
  这些比特值通过使用**位左移运算符**转换为十进制位置值。我们对每个位的位置进行多次移位，得出该位的十进制值。然后我们把它加到一个叫做output的变量中，并把它加总。
  
  关于这个块的详细情况，请参考比特左移。
  
  计算出的十进制值被用来查找字符符号，并将其存储在pinValue变量中。
  
  接下来我们在micro:bit的LED显示屏上显示我们收到的字符，这样我们就可以确认传输是正确的。
  
 ![](https://imgs.zhubai.love/58a1f2a2ffc546f9b419f10386361908.png)
  
  然后我们把存储在比特列表中的真/假值转换成1和0，这样我们就可以显示收到的字符的比特编码了。请参考上面描述的TFT2INT自定义块。
  
 ![](https://imgs.zhubai.love/8336820410624015a8b44e3613f9336f.png)
  
  最后，字符信息和它的比特模式显示在MicroBlocks脚本区。我们还显示了收到的比特的图形。
  
  ![](https://imgs.zhubai.love/43deb9e39254473b907f37c68756d776.png)
  
  > 注意：由于比特是按照从LSB到MSB的顺序发送和接收的，所以收到的字符的二进制编码是以反向顺序显示的。为了与开头部分的表格中所列的数值相匹配，请按从右到左的顺序阅读显示的1和0。
# 讨论

这个教程是基于一个单一的字符传输，以简化必要的编码，并把重点放在基础知识上。这里有一些其他的变化，实施起来会很有趣，证明所描述的概念已经被理解了。
库版本使用的代码，Button-A活动，能够以非常高的速度发送和接收：20波特到115200波特。尝试修改代码以达到这些更高的速度。
目前的练习发送大写字母A-Z。尝试修改代码以发送小写字母，以及数字0-9。
另一个好的扩展想法是修改基于库的代码或定制的编码版本，以发送和接收一个以上的字符；以及更长的字符串。

- 串口通信演示程序 [serialcommstutorial.ubp](/assets/serialcommstutorial_1672713798223_0.ubp)  #程序下载